'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Abi = require('web3-eth-abi');

var indexedAsHash = function indexedAsHash(type) {
  return !((type.startsWith('uint') || type.startsWith('int') || type.startsWith('byte') || type.startsWith('bool') || type.startsWith('address')) && !type.includes('['));
};

var decodeParameters = function decodeParameters(names, types, data) {
  var ret = {};

  if (names.length && names.length === types.length) {
    var result = Abi.decodeParameters(types, data);

    for (var i = 0; types.length > i; i += 1) {
      if (undefined !== result[i]) {
        ret[names[i]] = result[i];
      }
    }
  }

  return ret;
};

var createArgsParser = function createArgsParser(input) {
  var indexedNames = [];
  var indexedTypes = [];

  var nonIndexedNames = [];
  var nonIndexedTypes = [];

  input.forEach(function (_ref) {
    var indexed = _ref.indexed,
        name = _ref.name,
        type = _ref.type;

    if (indexed) {
      indexedNames.push(name);

      // dynamically-sized values do not get stored as-is, they are SHA3'd prior
      // to being indexed
      if (indexedAsHash(type)) {
        indexedTypes.push('bytes32');
      } else {
        indexedTypes.push(type);
      }
    } else {
      nonIndexedNames.push(name);
      nonIndexedTypes.push(type);
    }
  });

  return function (_ref2) {
    var topics = _ref2.topics,
        data = _ref2.data;

    // trim "0x.." from the front
    var indexedData = topics.slice(1).map(function (str) {
      return str.slice(2);
    }).join('');
    var nonIndexedData = data.slice(2);

    var args = {};

    Object.assign(args, decodeParameters(indexedNames, indexedTypes, indexedData));
    Object.assign(args, decodeParameters(nonIndexedNames, nonIndexedTypes, nonIndexedData));

    return args;
  };
};

var cachedParsers = new WeakMap();

var parseLog = exports.parseLog = function parseLog(logs, eventAbis) {
  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var filteredAbis = eventAbis.filter(function (_ref3) {
    var anonymous = _ref3.anonymous;
    return !anonymous;
  });

  var parsers = filteredAbis.map(function (thisAbi) {
    var key = JSON.stringify(thisAbi);

    if (!cachedParsers[key]) {
      var name = thisAbi.name,
          inputs = thisAbi.inputs;

      // compute event signature hash

      var sig = Abi.encodeEventSignature(name + '(' + inputs.map(function (_ref4) {
        var type = _ref4.type;
        return type;
      }).join(',') + ')');

      cachedParsers[key] = {
        name: name,
        sig: sig,
        parseArgs: createArgsParser(inputs)
      };
    }

    return cachedParsers[key];
  });

  var filteredLogs = logs;

  if (Object.keys(filter).length) {
    filteredLogs = logs.filter(function (_ref5) {
      var address = _ref5.address,
          blockNumber = _ref5.blockNumber;
      return (address === filter.address || undefined === filter.address) && (blockNumber === filter.blockNumber || undefined === filter.blockNumber);
    });
  }

  return parsers.reduce(function (retSoFar, _ref6) {
    var name = _ref6.name,
        sig = _ref6.sig,
        parseArgs = _ref6.parseArgs;

    var matches = filteredLogs.reduce(function (soFar, log) {
      if (log.topics[0] === sig) {
        soFar.push({
          name: name,
          args: parseArgs(log),
          log: log
        });
      }
      return soFar;
    }, []);

    retSoFar.push.apply(retSoFar, _toConsumableArray(matches));

    return retSoFar;
  }, []);
};